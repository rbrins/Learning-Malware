import nimcrypto

# This is using bytes

# Need to pad this, can use something like pbkdf2 with import nimcrypto/pbkdf2
var aliceKey = "Alice Key"
var aliceData = "Alice hidden secret"
# The IV needs to be different for each encryption, offensivenim using import nimcrypto/sysrand
# IV is equal to the aes256 block size 128 bits or 16 bytes
var aliceIv = "0123456789ABCDEF" 

var
  ectx, dctx: CTR[aes256]
  key: array[aes256.sizeKey, byte]
  iv: array[aes256.sizeBlock, byte]
  plainText = newSeq[byte](len(aliceData)) # this looks like it is allocating memory the same size as the size of aliceData by using a sequence of bytes (can be changed dynamically at run time, versus the fixed size of an array)
  encText = newSeq[byte](len(aliceData))
  decText = newSeq[byte](len(aliceData))

# Don't need to pad data here CTR mode works byte by byte
copyMem(addr plainText[0], addr aliceData[0], len(aliceData))


# need to pad the key size for actual application See key variable comment above
copyMem(addr key[0], addr aliceKey[0], len(aliceKey))

# Inital vector IV size for CTR[aes256] is equal to aes256 block size 128
# bits or 16 bytes
copyMem(addr iv[0], addr aliceIV[0], len(aliceIv))

# initialization of ctr[aes256] context with encryption key
ectx.init(key, iv)

# in CTR mode, no need to pad plain data
ectx.encrypt(plainText, encText)
# clear context of CTR[aes256]
ectx.clear()

echo "IV:                   ", toHex(iv)
echo "Plain Text (Hex):     ", toHex(plainText)
echo "Encrypted text (Hex): ", toHex(encText)
echo "Plain Text:           ", plainText
echo "Encrypted text:       ", encText
