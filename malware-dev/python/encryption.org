#+TITLE: Python Encryption and Decryption


* AES Notes


** CTR mode - Counter mode 
Turns the block cipher into a stream cipher. Each byte of plaintext is XOR-ed with a byte taken from a keystream. Allowing for no padding needed.

*** Example using PyCryptodome
[[https://pycryptodome.readthedocs.io/en/latest/src/cipher/classic.html#ctr-mode][CTR Mode Documentation]]

**** Encryption
#+BEGIN_SRC python :tangle ctr-example.py
import json
from base64 import b64encode, b64decode
from Crypto.Cipher import AES

data = b"secret"
key = b"Password12345678"
passediv = b"12345678"

cipher = AES.new(key, AES.MODE_CTR, nonce=passediv)
ct_bytes = cipher.encrypt(data)
#iv = b64encode(cipher.iv).decode('utf-8')
#ct = b64encode(ct_bytes).decode('utf-8')
#result = json.dumps({'iv':iv, 'ciphertext':ct})

#print(result)

#+END_SRC

**** Decryption

#+BEGIN_SRC python :tangle ctr-example.py

# this data was encrypted THEN encoded
base64_data = "NqXcW/rnZa/bcuNn829U150yjGMkElhyKcGMCeCifxVWrR1+jzdJVzrenpL5dDvkDvvXp+2KC1OM9T2qHQ=="

try:
#    b64 = json.loads(result)
#    iv = b64decode(b64['iv'])
#    ct = b64decode(b64['ciphertext'])
    decoded_bytes = b64decode(base64_data)
    print(decoded_bytes)
    d_cipher = AES.new(key, AES.MODE_CTR, nonce=passediv)
    pt = d_cipher.decrypt(decoded_bytes)
    print("The message was: ", pt)

except (ValueError, KeyError):
    print("Incorrect decryption")

#+END_SRC

*** Portable Function

#+BEGIN_SRC python :tangle aes_ctr.py
from Crypto.Cipher import AES
import argparse
import base64

encoding = 'utf-8'

def AES_CTR_encrypt(key: str, nonce: str, data: bytes):
    """All string data and encrypts to cipher text"""
    b_key = bytes(key, encoding) # blockSize
    b_nonce = bytes(nonce, encoding) # note only can be blockSize/2 max
    b_data = data

    cipher = AES.new(b_key, AES.MODE_CTR, nonce=b_nonce)
    return cipher.encrypt(b_data)

def AES_CTR_decrypt(key: str, nonce: str, ciphertext: bytes):
    """Takes in string key/nonce, and ciphertext bytes, returns plaintext"""
    b_key = bytes(key, encoding) # blockSize
    b_nonce = bytes(nonce, encoding) # note only can be blockSize/2 max
    
    cipher = AES.new(b_key, AES.MODE_CTR, nonce=b_nonce)
    return cipher.decrypt(ciphertext)

if __name__ == "__main__":
    parser = argparse.ArgumentParser("AES CTR Mode Encrypt / Decrypt Tool", description = "Using base64 to easily pass copyable text that is bytes underneath")
    parser.add_argument("-k", "--key", type=str)
    parser.add_argument("-n", "--nonce", type=str)
    parser.add_argument("-p", "--plaintext", type=str)
    parser.add_argument("-c", "--ciphertext", type=str)
    parser.add_argument("-d", "--decrypt", action="store_true")
    parser.add_argument("-e", "--encrypt", action="store_true")

    args = parser.parse_args()

    if args.encrypt == True:
        encrypted_bytes = AES_CTR_encrypt(args.key, args.nonce, bytes(args.plaintext, encoding))
        b64_data = base64.b64encode(encrypted_bytes)
        print(b64_data)

        if args.decrypt == True:
            decrypted_bytes = AES_CTR_decrypt(args.key, args.nonce, base64.b64decode(b64_data))
            print(decrypted_bytes)

    elif args.decrypt == True:
        decrypted_bytes = AES_CTR_decrypt(args.key, args.nonce, base64.b64decode(args.ciphertext))
        print(decrypted_bytes)

#+END_SRC
